# 인상적인 문장들 정리

## 1장 마이크로서비스
* 도메인 주도 설계(DDD), 지속적 배포(continuous delivery), 주문형 가상화(on-demand vitualization), 인프라스트럭쳐 자동화, 작고 자율적인 팀, 대규모 시스템 등의 분위기에 편승한 마이크로서비스는 실사용을 기반을 하나의 대세 내지는 패턴으로 부상했다.
* 황금률은 '다른 변경없이 특정 서비스만 변경하고 배포할 수 있는가?'(decoupling) 서비스를 잘 분리하려면 서비스를 올바르게 모델링하고 API를 제대로 만들어야 한다.
* 회복공학(resilence engineering)의 핵심은 격벽(bulkhead)이다. 즉 특정 컴포넌트에 장애가 발생하더라도 그 장애가 전파되지 않는다면 해당 문제를 격리하고 나머지 시스템을 계속 작동시킬 수 있다. 서비스의 경계야말로 명확한 격벽인 셈이다.
* 하나의 큰 모놀리식 서비스에서는 항상 모든 것을 함께 확장해야 한다. 만약 작은 서비스들로 구성되어 있다면 필요한 서비스만 확장할 수 있다. 온라인 패션몰인 길트(Gilt)가 이런 이유로 마이크로서비스를 도입했다. 길트는 2007년 Ruby on Rails로 작성한 모놀리식 애플리케이션을 2009년 자바로 작성된 10개의 마이크로서비스로 변환했고, 2011년에 스칼라를 적용했다. 2014년 Node.js를 도입하여 수백 개 이상의 마이크로서비스를 운영하고 있다.
* 마이크로서비스가 공짜도 은총알도 아니면, 황금 망치로 오인되는 일이 없어야 한다. 마이크로서비스는 분산 시스템과 연관된 모든 종류의 복잡성을 내포하고 있다. 마이크로서비스가 제공하는 혜택을 얻기 위해서는 배포, 테스트, 모니터링을 훨씬 더 잘 다루어야 할 것이다. 또한 시스템을 확대하고 회복력을 유지하는 방법에 대해 다르게 생각해야 할 것이다. 분산 트랜잭션이나 CAP 정리와 같은 것들이 골치 아플 수 있을 텐데 각오해야 할 것이다.

## 2장 진화적 아키텍트
* 필자는 우리가 바라는 IT 아키텍트의 역할을 더 잘 요약하는 다음의 비유를 좋아한다. 에릭 도넌버그는 아키텍트의 역할을 건축가보다는 도시 설계자에 가까운 의미로 접근해야 한다는 아이디어를 처음으로 필자와 공유했다. 도시 설계자의 역할은 다양한 정보 소스를 파악하고, 현재 시민의 요구에 부응함과 동시에 미래의 용도까지 고려하면서 도시 배치를 최적화 하는 것이다. 도시 설계자가 도시 발전에 영향을 미치는 방식은 흥미롭다. 그는 '특정 건물을 거기에 만들라'고 하는 대신 도시를 구역화한다.
* 넷플릭스는 데이터 저장 기술을 대부분 카산드라(cassandra)로 통일 했다. 비록 모든 경우에 적합한 최선의 대응책은 아닐지라도, 넷플릭스는 카산드라와 관련된 도구 및 전문지식을 통해 얻는 가치야말로 몇몇 특정 태스크에 더 적합할 수 있는 다수의 이종 플랫폼 확장을 지원하고 운영하는 것보다 더 중요하다고 생각했다.
* 만약 한 서비스는 HTTP 상에서 REST를 노출하고, 다른 서비스는 프로토콜 버퍼를, 또 다른 서비스는 자바 RMI를 사용하기로 결정한다면, 호출하는 서비스가 의사소통을 위한 다양한 스타일을 이해하고 지원해야 하므로 통합 작업은 악몽이 될 수 있다. 이것이 필자가 다이어그램 박스들 간에 벌어지는 이벤트를 걱정하고, 내부에서의 일에 대해서는 자유로워야 한다는 지침에 집착하는 이유다.
* 시스템 설계상의 결정은 모두 trade-off와 관련된다. 의사결정을 구조화(framing)화 할 수 있는 가장 좋은 방법은 성취해야할 목표에 기반하여 일련의 원칙과 실천 사항을 정의하는 것이다.
* 전략적 목표에서는 회사가 어디를 향해 나아가고 있는지, 그리고 고객을 행복하게 만들기 위해 어떻게 해야 할지 언급해야 한다. ex) '신규시장 개척을 위해 동남아시아로 영역 확장', '고객이 셀프서비스를 최대한 많이 사용하게 하자'
* 원칙은 더 큰 목표를 위해 해야 할 일을 정렬하는 규칙으로, 때로는 변경 될 수 있다. 예를 들어 조직의 전략적 목표 중 하나가 새로운 제품의 시장 출시 시간(time to market)을 줄이는 것이라면, 제품 출시 팀이 소프트웨어의 수명주기 전반에 대한 통제권을 가지고, 제품이 준비될 때 마다 다른 팀과는 독립적으로 출시하도록 원칙을 정할 수 있다. 원칙의 수는 10개 미만인 것이 좋다. 클라우드 애플리케이션 플랫폼인 헤로쿠(heroku)의 12가지 요소(www.12factor.net)는 헤로쿠 플랫폼 상에서 잘 동작하는 애플리케이션을 작성하기 위해 정리된 일련의 설계 원칙으로, 다른 맥락에 적용해도 효과적이다.
* 실천 사항(practice)은 원칙을 실행하는 방법으로, 업무 수행을 위한 자세하고도 실질적인 지침이다. 이것은 대개 기술 명세적이며, 어떤 개발자든 이해할 수 있도록 충분히 구체적이어야 한다.
* 아키텍트는 많은 것에 대해 책임을 진다. 그들은 개발을 이끌 수 있는 일련의 원칙을 정하고, 원칙들이 조직의 전략과 일치하도록 보장할 뿐만 아니라 이 원칙들로 인해 개발자를 비참하게 만드는 실천 사항이 만들어지지 않도록 해야 한다.
* 기술 리더의 역할은 사람들이 스스로 비전을 이해하도록 그들의 성장을 돕고, 비전을 결정하고 구현하는 데 적극적으로 참여할 수 있도록 만드는 것이다.

## 3장 서비스 모델링하기
* 무엇이 좋은 서비스를 만드는가? 바로 느슨한 결합(loose coupling)과 강한 응집력(high cohesion)이다.
* 서비스가 서로 느슨히 결합되어 있다면 하나의 서비스가 변경될 때 다른 서비스가 변경되는 일이 없다. 마이크로서비스의 요점은 시스템의 그 어떤 부분도 추가 변경할 필요 없이 특정 서비스를 변경하고 배포할 수 있다는 것이다.
* 특정 행위를 변경하고자 할 때는 한곳에서 변경하고(강한 응집력) 가능한 한 신속하게 릴리즈 할 수 있기를 원한다.
* 모든 도메인은 다수의 경계가 있는 콘텍스트(bounded context)로 구성되며, 각 콘텍스트 내에는 외부와 통신할 필요가 없는 것뿐만 아니라 경계가 있는 다른 콘텍스트 외부와 공유되는 것이 함께 존재한다. 경계가 있는 모든 콘텍스트에는 명백한 인터페이스가 존재하며, 그것은 어떤 모델이 다른 콘텍스트와 공유될지 결정한다.
* 경계가 있는 콘텍스트와 관련해서 필자가 좋아하는 또 다른 정의는 '명료한 경계에 의해 강제된 구체적인 책임'이다. 만약 여러분이 경계가 있는 콘텍스트로부터 정보를 원하거나 콘텍스트 내부의 기능을 요청하고자 한다면 모델을 이용하여 명료한 콘텍스트 경계와 의사소통해야 한다.

## 4장 통합
* 통합(마이크로서비스간의 통신)에 대한 올바른 이해는 마이크로서비스 관련 기술에서 가장 중요한 요소다. 잘못 통합하면 재앙이다.
* 마이크로서비스 간의 통신에 사용되는 API가 특정 기술에 종속되지 않도록 기술 중립성(technology-agnostic)을 유지하는 것을 매우 중요하게 생각하는 이유이기도 하다. 이는 마이크로서비스 구현에 기술 스택을 좌우하는 통합 기술을 회피하는 것을 의미한다.
* 서비스 협업 방식 측면에서 우리가 내릴 수 있는 가장 중요한 결정 사항 중 하나인 동기(synchronous)와 비동기(asynchronous)방식을 논의해야 한다. 통신은 동기식이어야 하는가 비동기식이어야 하는가? 이 근원적인 선택은 필연적으로 우리를 특정 세부 구현으로 이끈다.
* 서로 다른 이 두 통신 모드는 '요청/응답' 또는 '이벤트 기반'이라는 관용적인 두 가지 협력 방식을 가능하게 한다. 요청/응답 스타일은 클라이언트가 요청을 시작하고 응답을 기다리는 것이다. 이 모델은 동기 통신 방식과 명확히 일치하지만 비동기 통신에서도 잘 작동한다. 클라이언트는 작업 요청을 보내고 그 작업이 완료되었을 때 서버가 알려주도록 요청하는 콜백을 등록할 수 있다. 한편 이벤트 기반 협업에서는 모든 것이 뒤바뀐다. 클라이언트는 완료되어야 할 작업을 요청하는 대신 일(사건)이 발생했음을 알리고 다른 당사자들이 무엇을 해야 할지 알기 기대한다. 우리는 결코 다른 누구에게도 해야 할 일을 말하지 않는다. 이벤트 기반 시스템은 본질상 비동기적이다. 그리고 지능이 더 고르게 분산되어 있다. 즉, 비즈니스 로직이 핵심 두뇌로 집중화되기보다는 다양한 협업자들에 고르게 분배된다. 이벤트 기반 협업 역시 매우 결합도가 낮은 방식이다. 이벤트를 발산하는 클라이언트는 이벤트에 반응하는 대상이 누구인지 또는 무엇인지 전혀 알지 못한다. 이는 클라이언트 몰래 이벤트에 새로운 구독차를 추가할 수 있다는 의미다.
* 필자는 코레오그래피 방식의 시스템이 전반적으로 더 느슨히 결합하고 유연하며 변경을 보다 쉽게 수용하는 것을 알게 되었다. 시스템 경계를 넘어 프로세스를 모니터링하고 추적하는 부가 작업이 필요하지만, 오케스트레이션 방식에 지나치게 의존하는 구현체는 매우 취약하고 높은 변경 비용을 수반한다. 이러한 면에서 필자는 각 서비스가 자신의 역할을 영리하게 인식하는 코레오그래피 방식의 시스템을 매우 선호한다.
* 이벤트 기반의 비동기 통신시 고려해야 할 두 가지 주요 문제는 마이크로서비스가 이벤트를 발산하는 방법과 소비자가 생성된 이벤트를 찾는 방법이다. 전통적으로 RabbitMQ와 같은 메시지 브로커들은 두 문제를 모두 처리한다. 생산자는 API를 사용하여 브로커에 이벤트를 발행하고 브로커(중개자)는 이벤트가 도착하면 소비자에게 알릴 수 있도록 구독을 처리한다. 메시지 브로커 인프라스트럭쳐를 구축하고 운영하려면 부가적인 머신과 전문성이 요구되지만 일단 실현된다면 느슨히 결합된 이벤트 기반 아키텍처의 구현에 대단히 효과적인 방법이 된다. 이벤트를 전파하는 또 다른 대안은 HTTP를 사용하는 것이다. 아톰(ATOM)은 자원의 피드를 게시하기 위해 semantics를 정의한 REST 호환 사양서다. 고객 서비스는 변경될 때 해당 피드에 대한 이벤트만 발생하고, 고객 서비스의 소비자들은 단지 피드의 변경이 있는지 폴링만 하면 된다.
* 분산 시스템은 호출 방법의 구현 세부 사항을 추상화하고 더 쉽게 추론하게 하므로 Rx(reactive extension) 구현체와 아주 잘 어울린다. Rx의 백미는 하위 서비스에 대해 동시에 발생하는 호출들을 훨씬 쉽게 처리하면서 다수의 호출을 함께 조합할 수 있다는 것이다.
* 넷플릭스는 클라이언트 라이브러리를 특별히 강조한다. 사실 넷플릭스에서 사용되는 클라이언트 라이브러리는 시스템의 신뢰성과 확장성을 보장하려는 것이다. 넷플릭스의 클라이언트 라이브러리는 서비스 발견, 장애 모드(실패처리), 로깅, 그리고 실제로 서비스 자체의 본질과는 다른 측면들을 다룬다. 이러한 공유 클라이언트 없이는 넷플릭스의 대규모 확장 운영 상황에서 제대로 동작하는 각각의 클라이언트/서버 통신을 보장하기 어렵다. 그러나 넷플릭스의 한 관계자의 말에 따르면 시간이 지나면서 클라이언트 라이브러리는 클라이언트와 서버 사이에서 문제가 될 정도의 결합을 초래했다.
* 관심 없는 데이터의 변경들을 무시할 수 있도록 독자(reader)를 구현하는 것이 바로 마틴 파울러가 말하는 '관대한 독자(tolerant reader)' 패턴이다. (ex) XPath를 사용해 필드의 저장 위치는 개의치 않고 필드 추출하기)

## 5장 모놀리스 분해하기
* 스트럭쳐 101(Structure 101)과 같은 도구는 패키지 간의 의존성을 시각적으로 표현한다.
* 보상 트랜잭션을 수동으로 통제하는 방식의 대안은 분산 트랜잭션(distributed transaction)의 사용이다. 트랜잭션 관리자가 하부 시스템에서 수행되는 다양한 트랜잭션을 통제, 조정한다. 분산 트랜잭션은 복잡성을 증가시킨다. 또한 재시도, 보상 로직을 최종 방법으로 사용하는 시스템은 추론하기 더 어려우며 데이터의 불일치를 고치기 위해 다른 보상 행위가 필요 할 수 있다. 트랜잭션 자체를 표현할 구체적인 개념을 만들어라. 이것은 보상 트랜잭션과 같은 다른 작업을 실행할 여지를 주고 시스템의 복잡한 개념들을 모니터링하고 관리할 수 있는 방법을 제공한다. 예를 들어 '진행 중인 주문' 같은 개념을 만들 수 있다.

## 6장 배포
* 지속적 통합(CI)를 통한 핵심 목표는 모든 사람이 서로 동기를 맞추는 것이며, 그것은 새롭게 체크인된 코드가 기존 코드와 적절히 통합됨을 보장함으로써 달성할 수 있다. 이를 위해 CI 서버는 코드의 커밋을 감지하고, 체크아웃하고, 코드의 컴파일과 테스트 통과를 확인하는 것과 같은 몇가지 검증을 한다.
* 지속적 배포(CD) 빌드 파이프라인(build pipeline)을 기반으로 모든 체크인의 실환경 준비에 대한 지속적인 피드백을 얻고, 나아가 모든 체크인을 빠짐없이 릴리스 후보로 여기는 접근 방법이다.
* 우리가 배포하고자 하는 서비스는 모든 다양한 환경에서 동일해야 한다.
* 대규모 마이크로서비스를 다룰 때 이용되는 다른 인기 있는 방법은 환경 구성을 제공하는 전용 시스템을 사용하는 것이다.
* 사용하는 하부 플랫폼과 산출물이 어떤 것이든 간에 특정한 서비스를 배포하는 데 일관된 인터페이스를 유지하는 것은 필수다. 이 분야에서 오랜 기간 일하고 나서 필자는 어떤 배포도 실행시킬 수 있는 가장 타당한 방법은 매개 변수 전달이 가능한 한 줄의 명령행 호출임을 확신한다. 이것은 CI 도구에 의해 실행되는 스크립트로 또는 직접 입력함으로써 시작할 수 있다. 필자는 윈도우 배치부터 배쉬 쉘, 파이썬 패브릭 스크립트 등 다양한 기술 스택의 랩퍼 스크립트를 작성해왔다. 하지만 모든 명령행은 동일한 기본 포맷을 공유한다.